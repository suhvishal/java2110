
Envionment Setup 
-----------------------
    1. jdk or openjdk 8
    2. IDE / Editor 
            - Eclipse for JEE
            - IntellIj
            - STS - Spring tool suite 
    3. NodeJS 12.x 
    4. Database 
            - MySQL community 
            - Oracle 
            - H2 

    Java 
    -----------
    Programming language        : programming capabilities 

    Runtime Environment         : 

    Standard Library            : 



    JVM - java virtual machine 
        - responsible to execute program on the given platform 

    JRE - java runtime environment 
            - JVM + standard libraries 

    JDK - Java Development kit 
            - JRE + development tools i.e. javac, jar, debug, etc.


    Java SE 
        - standard libraries i.e. collection, util, io, etc. 
        - core java

    Java EE 
        - enterprise applications 
        - component based 
                - web components 
                        servlet, JSP, JSTL, EL 
                - distributed tech  
                        CORBA, EJB, web services 
        - Service oriented 
                - JTA, JMS, JAVA MAIL, JCA 

        - protocol based 
                - HTTPServlet 

    Java ME 
        - small devices 


   1 hr 
    ------------
        - java basics 
            - variable in java 
                    - local variables 

                        public class X {

                            void methodA(){
                                 int i;

                                //
                                //

                            }
                        }

                    - instance variables 

                    - static variables 

            - data types

                1. primitive types 

                    byte        -128 to 127     1 byte
                    short       
                    int 
                    long 
                    float
                    double 
                    boolean 
                    char 

                2. Reference types 
                        - variable of type arrays, strings, class, interfaces are ref types 
                        - they store reference to the objects in memory 

            - decision making 
                    if statement 
                    if-else statement 
                    if-else if - if statement 
                    switch statement 

            - looping statement 
                    - while loop 
                    - for loop 
                    - do while 



            int a = 10;
            int b = 20;

            - Arrays 
            ---------------
                    - store multiple values/elements of same type 
                    - arrays are objects in java 
                    - array size is fixed 
                    - you can have array of primitives as well as objects 

            - declare array variable 

                    <datatype>[] array-var-name;

                    int[] nums;    

            - create an array 
                    array-var-name = new <datatype>[size];
                    nums = new int[5];


















    class Product {

        static String category;

       
        
        int pid;
        String pname;
        float price;
    }


    Product p1 = new Product();         pid   pname   price 


Array Manipulation
----------------------

        int[] arr = {10,40,503,20,40,20,30,40};

        for(int i=0; i<arr.length; i++){
            ....
            ...
        }

        Enahanced for loop 
        -------------------------
        for(int loopVar : arr){

        }

        java.util package provides "Arrays" class, which provides methods to manipulate arrays 

        - int binarySearch(int[] arr, int searchValue)
        - boolean equals(int[] arr)
        - copyOf()
        - sort()

                int[] arr1 = {10,20,30};

                int[] arr2 = Arrays.copyOf(arr1, 2)


    int[] arr1 = {1,2,3,3,4,4,43,43, .......................};

	binarySearch(arr1, 0, 100, 77)


    Employee[] empArr = ..............................................


    Operators 
    ---------------
        - increment & decrement operator 
                pre-increment                post-increment 
                    ++x                         x++


                pre-decrement                   post-decrement 
                    --X                         x-- 



            int a  = 10;
            int b = ++a;
            system.out.println(b)       //11
            sysout.out.println(a)       //11


       - Arithmetic operators 
            + 
            -
            *
            /
            %

                byte + byte         = int 
                byte + short        = int 
                byte + int          = int 
                char + char         = int 
                char + int          = int 
                byte + char         = int 

                int + long          = long 
                float + double      = double 
                long + long         = long 
                long + float        = float 



            - String Concatenation 
            ----------------------
                

            - Relational operators 
            --------------------------
                    > 
                    < 
                    >=
                    <=
                    ==
                    !=

            - Assignment operators 
                a = a + 1       a+=1 

            - logical operators 



        POJO - plain old java objects 

                        class Employee {
                             //data/logic    
                        }


        Java Beans 
        ---------------

                - java beans are used to represent a data or certain business operations 

                - a class is called java bean, if it 
                        - implements Serializable interface 
                        - has a no-arg constructor 
                        - has all the members declared as private 
                        - has public getter/setter methods 


        OOPS Concepts 
        ---------------

        object
        -----------
                - object oriented programming languages 
                - object is an entity which has some state and behavior 

                        i.e. a pen ---- state = name, type, color, size, etc.
                                        behavior = write 
                             a person 

                             a bank account  --- state --- type, accountnumber, ......
                                                behavior - open, close, ...

        Class 
        --------
                - blueprint or template for objects 
                - we use classes to describe a type / entity 

        Object 
        -------
                - object is a living entity 
                - once a class is created, you can create any number of objects of that type 


        class <className> {

                //instance members
                //instance methods 
                //static members 
                //static methods 
                //constructors 
                //inner class
                //abstract methods 
        }

        class Car {

                //state/fields/datamembers/instance members
                String type;
                String model;
                String color;
                int speed;

                //constructor / special method / doesn't have return type / called automatically while create object
                //constructor is used to initalize values to the fields/datamembers
                Car(){

                }
        }


        class BankAccount {
              
                private long accountNumber;
                private double balance;

                public double getBalance(){
                        return this.balance;
                }

                public void setBalance(double amount){
                        //logic 
                        this.balance = amount;
                }

                public long getAccountNumber(){
                        return this.accountNumber;
                }

                //..
                //...
        }

        BankAccount b1 = new BankAccount();
         

        Encapsulation
        -------------
                - hiding the state or internal representation of an object from outsite the class 
                - allows controlling internal implementation
                - declare all the fields/datamembers as private 
                - provide  public getter/setter methods to access the data members 


        Method overloading  / Static binding / compile time polymorphism / Early binding 
        -------------------------------------------------------------------
                - writing multiple methods with same name but diff parameters is called overloading 
                - 2 methods are said to be overloaded when both method methods have same name but diff parameters 
                                - parameters should be diff in either type or numbers 

                - the right method is determined based on arguments passed while calling the method 
                - this decision is taken at compile 
                - in overloading exact match gets the highest priority
                - child class arugment gets priority than parent argument 
                - access modifier/ return type of the method is not considered in method overloading
                - automatic promotion
                        byte ---> short  |---- int -- long --- float --- double  
                                  char   |
                - in overloading, method with varargs has least priority                
                - overloading resolution always take place at compile time 
                        - the right method call is determined based on ref type (and not based on object type)

        
        this keyword
                - refer to the current instance 
        
        this() constructor 

        super keyword 
                - refers to the parent class 

        super() constructor 


        Inheritance
        ----------------
                - Reusability 
                - Maintainability 
                - Extendibility 

                - use 'extends' keyword to inherit from a super class 
                - a class can extend to only one class 
                - inheritance create IS-A relationship 
                - **in java, Oject class is the supermost class for all the classes implicitely 

                                Object 
                                  |
                                  |--> boolean equals(Object o)
                                  |-> int hashCode()
                                  |-> void wait(), void notify(), void notifyAll()
                                  |
                                Person 
                                   |
                                Employee 

        Association / Aggregation / Composition 
        -------------------------------------------
                - Association creates HAS-A relationship 
                - when a class has ref to another class 



                Aggregation:
                        - the objects do not own each other 
                        - the object can exist without another object 

                        - School  --- Student 

                Composition
                        - strong association 
                        - one object owns another object 
          
                        House   ----> Rooms 

                        Car ----> Engine 


        class Address {
                ..street, city, pin, state, ....
        }


        class Supplier {

                Address address;
        }


        class Customer {

                Address[] address;


        }


        final variable - cannot change value of variable once assigned 

        final method    - cannot be overridden in subclass 

        final class - cannot be sub-classed 

        class X{

                X(){
                        //initialize default values to the members 
                }

                 X(int a){

                }
        }

        X x = new X(3);

        abstract classes
        -------------------
                - we cannot instantiate an abstract class 
                - abstract classes can have public/private/protected members 
                - can have constructors, instance methods 
                - can have abstract methods 

                abstract class Car {

                        //data members/fields/instance members
                        
                        //instance methods

                        //constructors

                        //abstract methods 
                }

                class TataCar extends Car {

                }

                class BMWCar extends Car {

                }



        Abstract method
        -------------------
                - a method declared with 'abstract' keyword and without body
                - an abstract method must be implemented by its immediate subclass

                abstract class Car {

                        public abstract void move();
                       
                }

                class TataCar extends Car {

                        public void move(){
                                sout("this car moves smooth")
                        }
                }

                class BMWCar extends Car {

                        //override the method of super class
                        //re-define a super class method in subclass 
                        public void move(){
                                sout("this car moves fast");
                        }
                }

                class XyzCar extends Car {
                        //must override abstract method move();

                }

                Car car = new TataCar();
                car.move();                     //TataCar's  move();

                Car car = new BMWCar();
                car.move();                     //BMWCar's move() method



        Interface
        -------------------
                - set of requirements that a class has to implement 
                - interface has only public abstract methods (JAVA 7) and public static final data members  
                - a class  has to implement the interface and override the abstract methods 
                - a class can implement several interfaces 
                - an interface can extend another interface 
                - an interface can extends several interfaces 


                        interface A {
                                //methodA();
                        }

                        interface B {
                                //methodB();
                        }

                        interface C extends A, B {
                                //..
                        }

                        class X implements C{
                                methodA(){}
                                methodB(){}
                                //...
                        }

                interface Taxable {

                        public abstract double calcTax(double taxRate);
                }

                interface Deliverable {
                        public abstract void deliver();
                }

                class Toys implements Taxable {

                        public double calcTax(double taxRate){
                                // some code to calc tax value 
                                //return tax value
                        }
                }

                class Cloths implements Taxable, Deliverable {

                        public double calcTax(double taxRate){
                                // some code to calc tax value 
                                // return tax value
                        }

                        public void deliver(){
                                //...
                        }
                }


        **a variable of type superclass can reference to child object 

        Polymorphism / 
        ---------------------
                - a type can reference to diff objects at diff time, and based on the type of object 
                        it is pointing to, we want to invoke appropriate method 
                - this can be achieved through overriding 

                - Method Overriding / run time polymorphism / dynamic binding 
                - redefine a super class method in child class using the same method 
                        signature as super class


                1. only inherited methods are overridden 
                        class A {
                                public void methodA(){}
                        } 
                        class B extends A {
                                public void methodA(){}
                        }
                2. private, static, final methods of superclass cannot be overridden 

                3. overridden method must have same signature i.e. same name, same parameters

                4. overriding method must have same return type or subtype 

                         class A {
                                public Object methodA(){}
                        } 
                        class B extends A {
                                public <anyClass> methodA(){}
                        }
                5. overriding method must not have more restrictive access 
                        class A {
                                protected void methodA(){}
                        } 
                        class B extends A {
                                public void methodA(){}
                        }


        Encapsulation 
        Inheritance 
        Abstraction 
        Polymorphism

        String, StringBuilder, StringBuffer, StringTokenizer 
        -------------------------------------------------------

        String class 
        ----------------
                - create string object 
                - String objects immutable / not modifiable 

                1. String str = "Welcome";

                2. String str = new String("welcome");

                3. char[] charArr = {'h','e','l','l','o'}
                        String str = new String(charArr);


        String interning
        ----------------
                - jvm optimizes the amount of memory for string objects, by allocating only 
                \       one single copy of each literal string in the pool 


        String class methods 
        ----------------------
                int length()

                String concat(String s);

                boolean equals(String s)

                boolean equalsIgnoreCase(String s)

                char charAt(int index)

                int compareTo(String s)

                boolean startsWith(String s)

                boolean endsWith(String s)
                
                int indexOf(String s)           int indexOf(char ch)

                int lastIndexOf(String s)           int lastIndexOf(char ch)

                String toUpperCase()

                String toLowerCase() 

                String[] split();

        StringBuilder, StringBuffer
        ------------------------------



        StringTokenizer
        ----------------
                - allows to break a string into tokens 
                - StringTokenizer(String str)
                - StringTokenizer(String str, String delimiter)
                -...

        Wrapper classes 
        -----------------
                - for each primitive there is a corresponding referece type availalble at java.lang package 
                                i.e. for primitive int there is class called as Integer 
                - whever you want to treat primitives as ref types i
                        i.e. working with Collections 
                        i.e. working with Generics 
                - wrapper classes provides conversion methods 

                      int i =  Interger.parseInt("132");

                byte                    Byte 
                short                   Short 
                int                     Integer 
                long                    Long 
                char                    Character
                boolean                 Boolean 
                float                   Float 
                double                  Double  


        - Boxing 
                - conversion a primitve type into ref type 


                public void methodA(Object obj){

                }


                methodA(20);            //Integer object



        - Unboxing 
                - conversion of ref type to primitive type 


Java Essentials 
-------------------
        - Java Basics 
        - J2EE, J2SE, J2ME
        - JVM, JRE, JDK 
        - Decision making 
        - looping statements 
        - operators / expressions 
        - arrays 
        - String 
        - OOPS 
        - Object class i.e. toString()


Standard Library 
------------------

        Collection Framework 
        --------------------
                - provides dynamically allocated data structures 
                - java.util package provides set of interfaces, classes  


                        Iterable<E> interface 
                                |
                        Collection<E>  Interface 
                                |
                                |
                                |
                                |
        -------------------------------------------------------------------------------------------
        List<E> interface                 Set<E> interface                     Queue<E> interface 
                |                               |                                       |
                |                               |                                       |
                |                               |                                       |
        ArrayList<E>                        HashSet<E>                                  |
        LinkedList<E>                       LinkedHashSet<E>                    ---------------------------------------------------------------------------------
        Vector<E>                            <E>                               Deque<E> interface              BlockingQueue<E> interface               PriorityQueue<E>
        Stack<E>                                                                        |                               |
                                                                ---------------------------------------           ArrayBlockingQueue<E>
                                                                BlockingDeque<E> Interface      ArrayDeque<E>
                                                                        |
                                                                ArrayBlockingDeque<E>



                                        Map<K,V> interface 
                                                |
                                        HashMAp<K,V>
                                        LinkedHashMap<K,V>
                                        TreeMap<K,V>



Collection<E>  Interface 
--------------------------
        - it is the supermost interface in collection hierarchy 
        - Collection interface methods ....
                boolean add(Object obj)
                boolean addAll(Collection c)
                boolean remove(Object obj)
                int size() 
                boolean contains(Object obj)
                .....

List<E> interface 
---------------------
        - subinterface of Collection interface
        - it models an index based collection of items
        - inserts the elements based on insertion order 
        - allows duplicates
        - list interface methods 
                - boolean add(int index, Object obj)
                - boolean remove(int index)
                - .....


        - implementation classes of List<E> interface 

                1. ArrayList<E>
                        - uses 'resizable array' as data structure 
                        - initial size = 10 
                        - performance is slower compared to LinkedList i.e. lot of shifting is required while inserting/removing elements 

                2. LinkedList<E>
                        - uses 'double linked list' as data structure 

                3. Vector<E>
                        - similar to arraylist class 
                        - uses 'resizable array' as data structure 
                        - it is synchronized 

                4. Stack<E> 
                        - similar to arraylist class 
                        - uses 'resizable array' as data structure 
                        - it is synchronized 
                        - uses LIFO approach 


        - Creating a list 

                non-generic lists
                --------------------
                        ArrayList list = new ArrayList();
                        ArrayList list = new ArrayList(int capacity);

                        LinkedList list = new LinkedList();
                Generic lists
                --------------
                        ArrayList<Integer> numsList = new ArrayList();
                        LinkedList<String> namesList = new LinkedList();

                        List<Integer> numslist = new ArrayList();



        - Operations on list 
        -------------------------
                -- add, remove, retrieve elements from the list 
                -- 


Set<E> interface 
-------------------
        - subinterface of Collection interface
        - it models a collection of unique elements, doesn't allow duplicates 
         
                                        Collection<E> interface
                                                |
                                                |
                                           Set<E> interface 
                                                |---------> descrives methods to perform basic operations 
                                                |---------> add(), remove(), size(), contains()...
                                                |
                                                |
                        -------------------------------------------------------
                        HashSet<E>                                     SortedSet<E> interface 
                            |                                                   |----> describes some additional methods 
                            |                                                   |---> subSet(from, to), headSet(to), tailSet(from), first(), last()
                        LinkedHashSet<E>                                        |
                                                                        NavigableSet<E> interface 
                                                                                |----> descrives some more additional methods for navigation
                                                                                |---> lower(), floor(), ceiling(), higher(), descendingSet(), descendingIterator()
                                                                                |
                                                                            TreeSet<E>

        - implementation classes of Set<E> interface 

                1. Hashset<E>
                        - uses 'hashtable' datastructure 
                        - not synchronized
                        - doesn't not guarantee the order or insersion 

                2. LinkedHashSet<E>
                        - uses 'hashtable + double linked list' datastructure 
                        - not synchronized
                        - maintains insertion order

                3. TreeSet<E>
                        - uses 'balanced tree' datastructure 
                        - not synchronized
                        - maintains sorted order of elements 


        - Operations on set
        -------------------------
                - creating a set 
                - basic operations i.e. adding, removing, if set is empty, size of set etc. 
                - searching
                - iterating

        - ** hashCode() and equals() 
        --------------------------------
                - whevener we work with any hashtable based collection, we have to override both equals() and hascode() correctly 
                - hashCode()
                        - returns an integer value representing the current instance of the class 
                        - we have calculate this vlaue consistent with definition of equality of the calss 
                        - if we override the equals() method, we have have to override hashCode()

                - if two objects are equal, their hashcode is also equal 
                - if two objects are not equal, they may or may not have identical hashcode


        Natural ordering of elements 
        -------------------------------
                numbers         = alphanumeric 
                string          = alphabetic 
                date            = choronological 


        Comparable<E> interface 
        -------------------------
                interface Comparable<E>{
                        public int compareTo(E e);
                }

                the compareTo() method returns compare value 

                        0       = both objects are same 
                        >= 1     = the current object is greater than other object 
                        <= 1     = the current object is less than other object 


        Comparator<E> interface
        ------------------------- 
                - you can create external comparators 

                        interface Comparator<E>{
                                int compare(E objec1, E object2);
                        }


Queue<E> interface 
------------------
        - subinterface of Collection interface
        - it models a collection of items with FIFO approach, elements are stored in queue 


 Map<K,V> interface
 ---------------------
        -** not part of collection interface 
        - it models a collection of elements based on key-value pairs 
        - Keys cannot be duplicated 


                                MAp<K,V> interface 
                                        |
                                        |
                                        |
                                        |
                -----------------------------------------------------
                HashMap<K,V>                               SoretedMap<K,V> interface 
                     |                                              |         
                LinkedHashMap<K,V>                                  |
                                                            NavigableMap<K,v> interface 
                                                                    |
                                                                TreeMap<K,V>


        - map<K,V> interface methods 
        ---------------------------------

                        V put(K key, V value)

                        V get(K key)

                        boolean containsKey(Object key)

                        boolean containsValue(Object value)

                        Set<K> keySet()

                        Collection<V> values();

                        entrySet();


        - Map<E> implementation classes
        ------------------------------------

                1. HashTable<K,V>
                        - uses 'hashtable' as datastructure
                        - synchronized
                        - hashtable doesnt allow null key 

                2. HashMap<K,V>
                        - uses 'hashtable' as datastructure
                        - not synchronized / not threadsafe 
                        - hashmap allows one null key 

                3. LinkedHashMap<K,V>
                        - uses 'hashtable+double linked list' 
                        - ensures insertion order 

                4. TreeMap<K,V> 
                        - maintains sorted order of keys 


                class Manager{          //implement Comparable 
                        
                        //hashcode() and equals()


                }

                class Employee{

                }


                Map<Manager, List<Employee>> map = new TreeMap();               //or provide comparator 

                map.put(m1, list1);
                map.put(m1, list2);


        - Queue<E> interface                                                    Collection<E> interface 
        -------------------------                                                       |
                                                                                Queue<E> interface 
                                                                                        |
                                                                                        |
                                                                                        |
                                                     -----------------------------------------------------------------------------------------------------------------
                                                     LinkedList<E>              Deque<E> interface              BlockingQueue<E> interface               PriorityQueue<E>
                                                                                        |                               |
                                                                ---------------------------------------                 |
                                                                BlockingDeque<E> Interface      ArrayDeque<E>        ---------------------------------------------
                                                                        |                                            ArrayBlockingQueue<E>      PriorityBlockingQueue<E>
                                                                ArrayBlockingDeque<E>

        Queue operations
        -------------------
                - insert operation 
                - remove operation 
                - examine operation


        
        Queue<E> interface methods 
        ---------------------------

                insert                  add(e)                  offer(e)

                remove                  remove()                poll()

                examine                 element()               peek()


        Deque<E> interface methods 
        ------------------------

                insert                  add(e)                  offer(e)
                                        addFirst(e)             offerFirst(e)
                                        addLast(e)              offerLast(e)

                remove                  remove()                poll()
                                        removeFirst()           pollFirst()
                                        removeLast()            pollLast()

                examine                 element()               peek()
                                        getFirst()              peekFirst()
                                        getLast()               peekLast();

        BlockingQueue<E> interface methods 
         ----------------------------------

                insert                  add(e)                  offer(e)                put(e)

                remove                  remove()                poll()                  take()

                examine                 element()               peek()


        BlockingDeque<E> Interface methods 
        ------------------------------------
                insert                  add(e)                  offer(e)                put(e)
                                        addFirst(e)             offerFirst(e)           putFirst(e)
                                        addLast(e)              offerLast(e)            putLast(e)

                remove                  remove()                poll()                  take()
                                        removeFirst()           pollFirst()             takeFirst()
                                        removeLast()            pollLast()              takeLast()

                examine                 element()               peek()
                                        getFirst()              peekFirst()
                                        getLast()               peekLast();

        Implementation classes of Queue Interface 
        -------------------------------------------
                1. LinkedList 
                        List list = new LinkedList();
                        Queue queue = new LinkedList();

                2. PriorityQueue 
                        - maintains sorted order of elements 

                3. ArrayDeque 
                        - double headed queue 

                4. ArrayBlockingQueue 
                        - it is concurrent / synchronized
                        - it is capacity based queue 
                        - while inserting a new element, if the queue is full, it will be kept on waiting 
                                        untill space become availalble
                                
                5. PriorityBlockingQueue
                        - similar to ArrayBlockingDeque, but maintains sorted order of elements 

                6. DelayQueue 
                        - time based scheudling queue 



        boolean equals(Object obj) method
        ----------------------------
                - this method belongs to object class 
                - we can override the equals() method in any class, and use it to compare objects 


        =======================
                **default implementatio of equals() method in object class 
                **Preserving equality contract ---- equals() and hashCode()
                **ListIterator, Iterator and Enumerator 
        ========================


        IO  - Input / Output 
        -------------------------
                - java uses the concept of 'streams' to perform I/O 

                - Stream 
                        - a sequence of bytes, used to carry data from one place to another place 
                        - input stream is used to read data from diff input source 
                        - output stream is used to write data to diff output destinations 

                - java.io package provides diff classes which represents diff type of Streams 
                - all the classes in java.io package are categorized into... 

                        1. byte based stream classes 
                                - handle I/O on bytes 

                                InputStream                                     OutputStream 
                                  |->                                                   |->
                                  |->  DataInputStream                                  |->

                        2. character based steram classes 
                                - handle I/O on characters 

                                Reader                                  Writer 
                                 |->                                     |->



                Input operations from keyboard 
                -------------------------------------
                        1. Scanner class 
                        2. DataInputStream
                        3. InputStreamReader



        - InputStreadReader and OutputStreamWriter 
                - read/write character by character 
                - read/write with the given encoding 

        - FileReader and FileWriter 
                - read/write character by character 

        - BufferedReader and BufferedWriter 
                - reads/writes chunk of data at the from/to the disk 

        - FileInputStream and FileOuputStream 
                - read/write byte by byte 

        - BufferedInputStream and BufferedOutputStream 
                - read/write operation in bulk 

        - DataInputStream and DataOutputStream 
                - reads/writes primitive values 

        - ObjectInputStream and ObjectOutputStream

        

        Exception Handling 
        ---------------------------
                - any unwated / unexpected event that disturbs normal flow of the program is called Exception 
                - java provides diff classes to represent the unexpected events ie.. type of exception, message, stack trace

                - Why exception occures 
                        - invalid input by user 
                        - wrong logic 
                        - failure in physical resources 
                        - 

                1. find the problem (create an object of Exception type )
                2. inform someone that an error has occured (throw the exception object)
                3. someone would received the error information (catching the exception)
                4. take corrective actions (handling exceptions )


                Runtime Stack Mechanism
                ---------------------------
                        - for every thread JVM will create a runtime stack 


                Default Exception handling
                -------------------------
                        - in our program inside a method if an exception raised, that method is responsible to create an object of Exception and it should include the information about exception 
                                i.e. name of exception 
                                description of exception 
                                location of exception (stack trace)
                        - after creating exception object, it is handed over to JVM 
                        - JVM will check whether any corresponding method contain any execption handling code or not 
                        - if the method doesn't contain any exception handling code, then JVM terminates the method abnormally
                                and removes the stackframe 
                        - JVM will check the caller method for any exception handling code...
                                if not, then JVM terminates the caller method abnormally as well and removes the stackframe 
                        - this process will be continued until main();
                                and even the main() also doesnt have any exception handling code.. 
                                then JVM handovers the exception object to "DEfault Exception handler"  
                        - the default exception handler will terminate the program and prints the exception information 


                Hierachy of Exception class
                -----------------------------

                                                Throwable 
                                                    |
                          ------------------------------------------------------------------------
                          Error                                                         Exception
                                                                                            | 
                                        --------------------------------------------------------------------------------------------
                                        RuntimeException                       IOException              SQLException            .....
                                        |-> ArithmeticException
                                        |-> NullPointerException
                                        |-> ClassCastException 
                                        |-> IndexOfBoundsException 
                                        ....

                Checked exceptions
                        - exception that must be handled using try- catch block 
                                otherwise you can declare it to be thrown

                Unchecked exceptions 
                        - all the RuntimeExceptions are unchecked 


                how to handle exception 
                --------------------------
                        1. using try catch block 

                                        try {
                                                //code to be monitored 
                                                //..
                                                //..

                                        }catch(InputMismatchException e){
                                                //print a message
                                                //log the exceptions 
                                        }

                                ** try with multiple catch blocks 
                                        try {
                                                //code to be monitored 
                                                //..
                                                //..

                                        }catch(InputMismatchException e){
                                                //print a message
                                                //log the exceptions 
                                        }catch(ArithmeticException e){
                                                //print a message
                                                //log the exceptions 
                                        }
                                        catch(SomeOtherException e){
                                                //print a message
                                                //log the exceptions 
                                        }catch(Exception e){
                                                //generic corrective actions 
                                        }
                        2. finally block 
                        ------------------
                                FileInputStream fis = null;

                                 try {
                                        fis = new FileInputStream("somefile.txt");

                                        //do some operations on the file...

                                           
                                 }catch(Exception e){

                                 }finally{
                                         if(fis!=null)
                                                fis.close()  
                                 }
                        3. try with resources block 
                                try(fis = new FileInputStream("somefile.txt")) {
                                        //do some operations on the file...         
                                 }catch(Exception e){

                                 }

                        4. throws keyword 
                        ----------------------
                                - thorows keyword is used to declared only checked exceptions 
                                - we delegate the reponsibility of exception handling to the caller 
                                - we can use throws keyword with only methdos/constructors
                                - we can throws keyword only for Throwable objects 

                        5. throw 
                        ---------------
                                - to manually hand over the exception object to JVM 


        Threading / Concurrency API 
        -------------------------------
                - ability to execute more than 1 tasks at a time 
                - each task is executed in a separate thread 
                - concurrency is achieved by sharing CPU's processing time amoung the threads 

                - advantages    
                --------------- 
                        - increase performance & productivity 
                        - high responsiveness 
                        - leads to more appropriate program structure 

                - challenges 
                        - ensuring the data consistency 
                        - to avoid deadlock 


                - main thread
                ------------------
                        - all java programs are always started with one thread - called as main thread 
                        - from that thread you can create another threads 

                Thread class 
                ----------------
                        - represents a unit of execution 

                Runnable interface 
                ----------------------
                        - represents a task that can be executed by a thread 
        
                how to pause a thread 
                --------------------
                        - you can make currently running thread pauses its execution by invoking Thread.sleep(milliseconds) method 

                                Thread.sleep(4000); 
                how to interrupt a thread
                -------------------------------
                        - interrupting a thread can be used to stop or resume the execution of that thread from another thread 

                how to make a thread waits for another thread 
                        - this is called joining a thread
                        - using join() method  


                Concurrency API 
                -----------------
                        - java.util.concurrent 
                                        - provides many utility classes useful in concurrent programs 
                                        - i.e. Executors, thread pool management, scheduled task execution 

                        1. Execute tasks by multiple threads using managed thread pool 
                                - ExecutorService 



        SQL
        ------------
                - structured query language 
                - execute queries against database 

        JDBC API
        ----------      
                - jdbc api is a specification / standard 


                - Driver 
                        - helps to communciate with the database 
                        - types of drivers      
                                1. TYPE I - JDBC-ODBC Bridge Driver 
                                2. TYPE II - Native Library 
                                3. TYPE III - jdbc-net, pure java driver 
                                4. TYPE IV - thin driver  / pure java driver 

                - DriverManager 
                        - helps to create / manage connection using appropriate driver 
                        - DriverManager.getConnection("url", "user", "pass");

                - Connection
                        - represents the connection with the database  

                - Statement 
                        - object represents sql query and helps to submit/execute the query to the db


                        1. Statement object 

                             Statement stmt  =   conn.createStatement();

                             - methods of Statement object 
                             -------------------------------
                                int executeUpdate(String sql)
                                        - INSERT / UPDATE / DELETE operations 
                                        - returns a number representing no. of rows affected 

                                ResultSet executeQuery(String sql)
                                        - SELECT operations 
                                        - it returns an object of ResultSet, which represents a table of data fetched by the seelct query 

                                boolean execute(String sql)
                                        - it is used to execute any query 
                                        - returns true if the query create any resultset object 


                        2. PreparedStatement object 
                                - represens pre-compiled and parameterized query 
                                
                             PreparedStatement stmt = conn.preapreStatement(sql);

                        3. CallableStatement object 

                             CallableStatement stmt = conn.preapreCall()


        ResultSet object 
        ------------------------

                - represents the table of data fetched from db 
                - resultset object has a cursor, which by default points to the row before 1st row 
                - .next() method advanced the cursor to the next row 
                - getXXXX(int columnnumner) methods are used to read the data given column number / column name 

                .next()

        
        --->            '101','Mitul','Mumbai','2000'
                        '102','Bhakti','Mumbai','1500'
                        '103','Mohit','Pune','2100'
                        '104','Saurabh','Pune','3100'
                        '105','Vishal','Pune','2300'




        com.demo.model 
        class Users {

                userid 
                email 
                password 
                fullname        
        }

        com.demo.client 

        UserMainTest{
                psvm(){
                        //CRUD operation on the User
                }
        }

        com.demo.dao
        class UserDAO{

                //collection object

                User create(User u){
                        //insert the given user into a collection 
                }

                User update(User u){
                        //update an existing user based on given details 

                }

                User get(int userid){

                }

                User delete(int userid){

                }

                List<User> getAll(){

                }

                int count(){

                }

        }